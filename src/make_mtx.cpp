#include <algorithm>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <random>
#include <string>
#include <unordered_set>
#include <vector>

static int64_t to_i64(const char* s) { return (int64_t)std::atoll(s); }

int main(int argc, char** argv) {
  if (argc < 5) {
    std::cerr << "Usage: " << argv[0]
              << " <rows> <cols> <K_per_row> <out.mtx> [seed]\n";
    return 1;
  }

  const int64_t rows = to_i64(argv[1]);
  const int64_t cols = to_i64(argv[2]);
  const int64_t K    = to_i64(argv[3]);
  const std::string out = argv[4];
  const uint64_t seed = (argc >= 6) ? (uint64_t)std::strtoull(argv[5], nullptr, 10) : 1ULL;

  if (rows <= 0 || cols <= 0 || K <= 0) {
    std::cerr << "Error: rows, cols, K must be > 0\n";
    return 2;
  }
  if (K > cols) {
    std::cerr << "Error: K_per_row cannot exceed cols\n";
    return 3;
  }

  const int64_t nnz = rows * K;

  std::ofstream f(out.c_str());
  if (!f) {
    std::cerr << "Error: cannot open output file: " << out << "\n";
    return 4;
  }

  f << "%%MatrixMarket matrix coordinate real general\n";
  f << "% generated by make_mtx.cpp (random, K nnz/row, seed=" << seed << ")\n";
  f << rows << " " << cols << " " << nnz << "\n";

  std::mt19937_64 rng(seed);
  std::uniform_real_distribution<double> dist_v(-1.0, 1.0);
  std::uniform_int_distribution<int64_t> dist_j(1, cols);

  std::vector<int64_t> js;
  js.reserve((size_t)K);
  std::unordered_set<int64_t> used;
  used.reserve((size_t)(K * 2));

  for (int64_t i = 1; i <= rows; ++i) {
    js.clear();
    used.clear();

    while ((int64_t)js.size() < K) {
      const int64_t j = dist_j(rng);
      if (used.insert(j).second) js.push_back(j);
    }

    std::sort(js.begin(), js.end());

    for (int64_t t = 0; t < K; ++t) {
      f << i << " " << js[t] << " " << dist_v(rng) << "\n";
    }
  }

  return 0;
}

